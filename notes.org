* 4.01 Email Regarding Project / concerns about Choi et. al. 2011
Some concerns regarding model referenced in a Choi et. al. paper describing NaV1.7 NaV1.8 activity in a small diameter sensory afferent soma. 
At this time, getting source code is unlikely.
https://paperpile.com/app/p/3f0c8cd7-9f85-0980-8494-8f3fdbdd17ef
** Concerns
<<#>> are areas of confusion.
In Materials and Methods:

Passive membrane properties of the model neuron
"Action potential firing was studied using a single compartment cylindrical model of length 30 μm and <<1>>radius 23 μm, simulating a small sensory neuron with a 2,168 μm2 surface area and <<2>>20.2 pF/cm2 capacitance, based on electrically and microscopically measured values (Choi et al. 2007)."

1. Is this "radius 23 μm" value the radius or the diameter? It seems like this is the diameter as that will provide a 2,168 um2 surface area.
2. Can this "20.2 pF/cm2" value be clarified? It seemed very low. When Choi et al. 2007 was reviewed, the cell capacitance reported there is around 26 pF which, assuming same surface area of 2,168 μm2 (2.168e-5 cm2) should give a value around 1.2e6 pF/cm2. It seems like 1.2e6 pF/cm2 -- or 1.2 μF/cm2 happens to be closer to capacitance of other models. 

KDR potassium current
"The KDR current was defined as: IKDR = gKDR * n * (V − Ek), where gKDR is the delayed rectifier potassium conductance and n is a dimensionless activation variable that varies between 0 and 1. The kinetic characterization of the channel described by Schild et al. (1994) has been used <<1>> with alphan = 0.001265 * (V + 14.273)/{1 − exp[(V + 14.273)/−10]}; betan = 0.125 * exp(V + 55/−2.5); and ninf = 1/{1 + exp[(V + 14.62)/−18.38]}. The peak conductance for KDR (gKDR) was set to 0.0035 S/cm2, which corresponds to 6 nA potassium current at 0 mV."

1. Can the equation for tau be clarified, we assumed it to be:
taun = 1 / (alphan + betan)
As it was not given. However, when reviewing the prior paper, the tau equation is different. Because of this, there is some confusion over whether this change to tau should be used.
tau as given in Schild et al. (1994)
taun = (1 / (alphan + betan)) + 1

Nav1.8 sodium current.
The Nav1.8 sodium current (INav1.8) was best fit with a HH model that employed <<1>> only one activation gate: INav1.8 = gNav1.8 * m * h * (V − ENa), where gNav1.8 is the Nav1.8 sodium conductance and m and h are dimensionless activation and inactivation variables that vary between 0 and 1. Based on previous reports (Herzog et al. 2001; Sheets et al. 2007), we defined the following equations for Nav1.8 m and h <<1>>: m = m + [1 − exp(−dt/taum)] * (minf − m), h = h + [1 − exp(−dt/tauh)] * (hinf − h), alpham = 2.85 − (2.839)/{1 + exp[(v − 1.159)/13.95]}; betam = (7.6205)/{1 + exp[(v + 46.463)/8.8289]}; taum = 1/(alpham + betam); minf = alpham/(alpham + betam); tauh = (1.218 + 42.043 * exp{−[(v + 38.1) ∧ 2]/(2 * 15.19 ∧ 2)}); hinf = 1/{1 + exp[(v + 32.2)/4]}. The peak current of 25 nA was modeled by setting the peak value gNav1.8 to 0.026 S/cm2, which was chosen to match experimental values (Choi et al. 2007; Cummins and Waxman 1997).

1. There is confusion over the use of the modelling with only one m, the "INav1.8 = gNav1.8 * m * h * (V − ENa)" equation, as the equations for rate/ tau, inf equations:

alpha_m = 2.85-(2.839)/(1+exp((v-1.159)/13.95))
beta_m = (7.6205)/(1+exp((v+46.463)/8.8289))

tau_h = (1.218+42.043*exp(-((v+38.1)^2)/(2*15.19^2)))
inf_h = (1)/(1 + exp((v+32.2)/4))

all come from Sheets et al. 2007, though in this paper, the formula for current does not use a single m to describe activation but instead is:

ina = gnabar * m^3 * h * (v-ena)

The one activation gate from Herzog et al. 2001, which uses current equation described in the paper has characterised m, h differently:

alpham  = 1.032/{1 + exp[(υ + 6.99)/−14.87115]}
betam   = 5.79/{1 + exp[(υ + 130.4)/22.9]}

alphah  = 0.06435/{1 + exp[(υ + 73.26415)/3.71928]}
betah   = 0.13496/{1 + exp[(υ + 10.27853)/(−9.09334)]}
* 4.12 Calculating proper nseg given a dlambda and max frequency #techdetails
Link is here:
https://www.neuron.yale.edu/neuron/static/docs/d_lambda/d_lambda.html
Some additional observations regarding nseg calculation in myelinated axons:
https://www.neuron.yale.edu/phpBB/viewtopic.php?t=2271
** Implemented in python:
def cal_nseg( sec, freq, d_lambda ):
#neuron+python of https://www.neuron.yale.edu/neuron/static/docs/d_lambda/d_lambda.html
    nseq = lambda fc_: int((sec.L / (d_lambda * fc_) + 0.9) / 2) * 2 + 1
    fpfrc = 4 * h.PI * freq * sec.Ra * sec.cm
    h.define_shape()
    fc = 0
    n3d = sec.n3d()
    if n3d < 2:
        fc = 1e5 * h.sqrt(sec.diam / (fpfrc))
        return nseq(fc)

    x1 = sec.arc3d(0)
    d1 = sec.diam3d(0)

    for i in range(n3d):
        x2 = sec.arc3d(i)
        d2 = sec.diam3d(i)
        fc += (x2 - x1) / h.sqrt(d1 + d2)
        x2 = x1
        d2 = d1

    fc *= h.sqrt(2) * 1e-5 * h.sqrt(fpfrc)
    return nseq(sec.L/fc)
* 4.21 Notes on cell parameterization on netpyne
Note that due to storage of cell parameters in dictionaries
copy.deepcopy() does not work with cell parameters (recursion limit reached)
Pushed onto genrn git as commit to revisit this issue later ...
** Post on Slack
2:00 PM
jchen.6727 also, I'm curious about this --
the cellParams nested dictionary structure can causes issues when trying to vary individual parameters through a cell population
for instance:
----------------------------------------------------------------------
# some cell with soma length of 5
cellParams = {...'secs': {...'soma': {'geom': {'L':5...}...}...}...}
netParams.cellParams['length=5'] = cellParams
# some cell with soma same as before but length of 10
cellParams['secs']['soma']['geom'] = 10
netParams.cellParams['length=10'] = cellParams
----------------------------------------------------------------------
Since these parameters being handled as pointers, we are changing the length of both cells to 10.
copy.deepcopy() doesn't seem to work on these cellParams dictionaries because of a recursion limit?
various ways to handle this case though so
2:07 PM
jchen.6727 including parameterization via batchfile in context of single cells only
or importing a whole bunch of cell parameters to generate new dictionaries -> essentially doing "deepcopy"
* 4.22 using re and lambda functions to handle data grouping for analysis
Can use re and lambda to filter strings and cell ids to retrieve a specific trace or group of traces
** select excerpts from code
# use of dictionary to define several different "groups" to be plotted, these groups contain
tracegroups = {
    ...
    'current(Na)' : {'rgx': re.compile('NaV')       , 'xaxis': 't (ms)', 'yaxis': 'i (nA/cm2)' , 'conds': lambda id: id == 0},
}
...
for group in tracegroups:
    grp = tracegroups[group]
...
    grp['rgx'].search(key)
...
        grp['conds'](id)
* 4.24 checking the ion of an added mechanism
** added more functions to genrn to handle mechanisms
can now get mechanisms of a section, as well as mechanisms by section by ion:
with the developed modules, this is done via
mechlist = cell('secname').ions[ion]
easier to set up containers to store important attributes of a section in future
note that pythons getattr(), hasattr(), setattr() are very useful given neuron's proclivity to "hide" variables in difficult to access places
*** TODO set up a similar mechanism for point processes
*** TODO look into cython compilation
** work on neuron+python script to evaluate cells generated by genrn()
** now compiling all NaV isoforms, handling within python
* 4.25 notes on recording from point processes, changing h.dt during a simulation
** process for recording from a point process requires some finesse as recording needs to be done from the point process object.
*** excerpt from netpyne code, cell.py:196
if 'mech' in params:  # eg. soma(0.5).hh._ref_gna
    ptr = getattr(getattr(self.secs[params['sec']]['hObj'](params['loc']), params['mech']), '_ref_'+params['var'])
elif 'synMech' in params:  # eg. soma(0.5).AMPA._ref_g
    sec = self.secs[params['sec']]
    synMech = next((synMech for synMech in sec['synMechs'] if synMech['label']==params['synMech'] and synMech['loc']==params['loc']), None)
    ptr = getattr(synMech['hObj'], '_ref_'+params['var'])
** getting TODO:120 done would increase usefulness of genrn() in this sense
** work on nrnCSA.py
*** stims, traces implemented in a way that handles generic inputs.
*** parameter variation at specific times possible, currently used to implement dt variation.
** DONE h.stdinit() discrepancy in v_init, does not seem to initialize to correct values, additional h.finitialize(h.v_init) look into this
note that stdrun library can be found at /nrn/share/lib/hoc/stdrun.hoc
looks like v_init is not being changed properly with just h.v_init assignment.
*** changing dt after starting a simulation requires a call to h.setdt()
https://www.neuron.yale.edu/phpBB/viewtopic.php?t=2665
* 4.26 notes on recording current
** the value recorded at segment is a current density (mA/cm2), to calculate for current at a segment, need to know area of the segment.
** with a genrn() this is done through:
** genrn.sec(x).area() * 1e-8
** total surface area of a cell can also be calculated through:
area = 0
for sec in genrn:
    for seg in sec:
        area += seg.area()
area *= 1e-8
** area returns in microns squared
** unit conversion:
additional calculations - surface area at our recording (current density * surface area = current)
mA/cm2 * um2 * (cm2 / (1e8 * um2))(=1) * ((1e6 * nA) / mA)(=1)
mA * um2 * cm2 * 1e6nA                      mA                      nA*cm2   
----------------------  conversion is:  D (-----) * A (um2) * 1e-2 -------- = D * A * 1e-2 (nA)                        
  cm2 * 1e8um2 * mA                         cm2                     um2*mA
** examples of mutable objects, python
a = [1,2,3]
b = [a]*3
b
Out[4]: [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
a[2] = 'foo'
b
Out[6]: [[1, 2, 'foo'], [1, 2, 'foo'], [1, 2, 'foo']]
** some list comprehensions, python
[i if y else z for i in arr]
i if condition y is true, z if condition y is false for i in arr
** issue with L, diam caught when evaluating with area()
on printout of area, caught issue with modifications to L, diam assignments not being reflected on the section.
ultimately, the best method of catching this was using h.psection(), which has been implemented within the genrn() repr function (can be called when displaying the object)
value assignment automatically causes creation of the variable of an object.
on another note, the area of the default segment happens to be: 157079.63267948964
* 4.27 updated genrn
** genrn now has all section properties handled together (instead of being split into morphology--L, diam, nseg-- and electrophysiology--cm, Ra)
** upgraded to Ubuntu 20.0.4 LTS. (everything else seemed to work but getting neuron to run again requiring excising conda from my machine...)
*** python/conda seems to have been affected, including neuron and netpyne.
*** issue with reinstalling neuron as well. seems like something happened to libmemacs -> libncurses?
(base) jchen@18-04-4:~/nrn$ sudo make -j
...
make[3]: Entering directory '/home/jchen/nrn/src/nrniv'
/bin/bash ../../libtool  --tag=CXX   --mode=link mpic++  -g -O2   -o nrniv nvkludge.o ../ivoc/nrnmain.o ../ivoc/ivocmain.o ../oc/modlreg.o ../oc/ockludge.o ../nrnoc/libnrnoc.la ../oc/liboc.la libnrniv.la ../ivoc/libivoc.la ../oc/liboc.la ../nrnmpi/libnrnmpi.la     ../gnu/libneuron_gnu.la ../scopmath/libscopmath.la ../sparse13/libsparse13.la ../sundials/libsundials.la ../memacs/libmemacs.la ../mesch/libmeschach.la  /usr/local/iv/x86_64/lib/libIVhines.la  ../nrnpython/libnrnpython.la -L/home/jchen/anaconda3/lib -lpython3.7m -lpthread -ldl -lutil -lrt  -R/home/jchen/anaconda3/lib ../readline/libreadline.la -Wl,-Bsymbolic-functions -lncurses -ltinfo  -lm -ldl
libtool: link: mpic++ -g -O2 -o .libs/nrniv nvkludge.o ../ivoc/nrnmain.o ../ivoc/ivocmain.o ../oc/modlreg.o ../oc/ockludge.o -Wl,-Bsymbolic-functions   ../nrnoc/.libs/libnrnoc.so ./.libs/libnrniv.so ../ivoc/.libs/libivoc.so ../oc/.libs/liboc.so ../nrnmpi/.libs/libnrnmpi.so ../gnu/.libs/libneuron_gnu.so ../scopmath/.libs/libscopmath.so ../sparse13/.libs/libsparse13.so ../sundials/.libs/libsundials.so ../memacs/.libs/libmemacs.so ../mesch/.libs/libmeschach.so /usr/local/iv/x86_64/lib/libIVhines.so ../nrnpython/.libs/libnrnpython.so -L/home/jchen/anaconda3/lib -lpython3.7m -lpthread -lutil -lrt ../readline/.libs/libreadline.so -lm -lX11 -lncurses -ltinfo -ldl -Wl,-rpath -Wl,/usr/local/nrn/x86_64/lib -Wl,-rpath -Wl,/usr/local/iv/x86_64/lib -Wl,-rpath -Wl,/home/jchen/anaconda3/lib
/usr/bin/ld: ../memacs/.libs/libmemacs.so: undefined reference to `tgoto@NCURSES6_TINFO_5.0.19991023'
/usr/bin/ld: ../memacs/.libs/libmemacs.so: undefined reference to `tgetent@NCURSES6_TINFO_5.0.19991023'
/usr/bin/ld: ../memacs/.libs/libmemacs.so: undefined reference to `tgetnum@NCURSES6_TINFO_5.0.19991023'
/usr/bin/ld: ../memacs/.libs/libmemacs.so: undefined reference to `tgetstr@NCURSES6_TINFO_5.0.19991023'
/usr/bin/ld: ../memacs/.libs/libmemacs.so: undefined reference to `tputs@NCURSES6_TINFO_5.0.19991023'
collect2: error: ld returned 1 exit status
make[3]: *** [Makefile:748: nrniv] Error 1
make[3]: Leaving directory '/home/jchen/nrn/src/nrniv'
make[2]: *** [Makefile:519: all-recursive] Error 1
make[2]: Leaving directory '/home/jchen/nrn/src'
make[1]: *** [Makefile:656: all-recursive] Error 1
make[1]: Leaving directory '/home/jchen/nrn'
make: *** [Makefile:514: all] Error 2

(base) jchen@18-04-4:~/nrn$ dpkg -l '*ncurses*'
*** can use dpkg -l '*packagename*' to look for specific packages
*** Root issue is conda? Uninstalled and now everything is working again
*** BUG.am error:
BUG.am: error: 'install.sh' is an anachronism; use 'install-sh' instead
happens when there is an install.sh in the outer directory
** seems like a big caveat for conda, as this is the second time this particular environment handler has caused issues.
** PyCharm adding a path (in cases where avoiding pip3)->
Project->Python Interpreter->Gear Button->Directory Button->Plus Button
** How to find the USEION var associated with a file, python.
if mechanism was gabaat, could use:

regstr = re.compile("USEION ([A-Za-z0-9]+) ")
mobj = regstr.search(h.gabaat.code)
ion = mobj.group(1)

to get the ion string... assuming that only one USEION per mode

regstr = re.compile("USEION ([A-Za-z0-9]+) ")
ions = regstr.findall(h.gabaat.code)

* 4.28 NaV conduction -> vclamp -> current
*** conduction as specified in original paper https://paperpile.com/app/p/3f0c8cd7-9f85-0980-8494-8f3fdbdd17ef
poorly sourced or there are typo's here when describing NaV currents (I hesitate placing my trust in the original paper given issues as stated above)
"The peak current of 15 nA was modeled by ..." 
peak current when what? during an AP or during a vclamp stim at some arbitrary setting?
no external validation here.
** HH nav17 conductivity
*** however, as a starting point, here are the conduction values given...
nav17 is HH, nav18 is MM
mechs  = { nav17 : {'gnabar': 0.018 },
           nav18 : {'gnabar': 0.026 },
          'kdr'  : {'gkbar' : 0.0035},
          'ka'   : {'gkbar' : 0.0055},
          'pas'  : {'g': 5.75e-5, 'e': h.v_init}}
*** see https://paperpile.com/app/p/b70779e3-5b15-026f-bec6-3b4f7d9a7969 which provides non-silico data in table 1
whole cell patch-clamp
NaV1.7 -> -2.69 nA : 2.11 nA (n=17)
NaV1.8 -> -6.96 nA : 8.97 nA (n=17)
admittedly the stdev is worrying (noted in the paper)
*** vclamp is -57 -> 10 mV
currents
simulation           experimental (whole cell patch-clamp)
nav17 -> -1.40 nA -> target -2.69 nA
nav18 -> -6.14 nA -> target -6.96 nA
kdr   -> +5.81 nA
ka    -> +1.64 nA
*** revise conductivity
revise 
nav17 -> 2.7/1.4 * 0.018 -> gnabar set to ~0.035 umho
nav18 -> 7/6.14 * 0.026 -> gnabar set to ~0.03 umho
** MM nav17 conductivity...
** when using the Markov Model
simulation for nav17
peak at -0.001 nA
*** revised conductivity (in other words, the MM serves as a poor choice)
nav17 -> 2.7/0.001 * 0.018 -> gnabar @ 48.6 umho
** MM nav18 has a strange spike in current upon deactivion
*** upon transition from 10 mV -> -57 mV, current peak.
*** magnitude of the continuous wave is -7 nA, but something approaching a dirac delta with magnitude of -11.72 observed
*** something that would normally be caught in a trap function...
** revised, using HH nav17 and MM nav18. first sweep is tagged: data_4_28_ab8467
** current too strong, ka too low?
** current range from 0 -> 0.3 nA more appropriate for capturing threshold of depolarization; however, still need to resolve ka?
** no parameters for conductance setting of K channels
** also added KA from a small diameter DRG of the bladder as SUFFIX 'kam', original SUFFIX 'ka' from paper and Sheets now kas

* 5.01 Discussion on dorsal horn modelling
** Have been posting notes on dorsal horn network to github, some observations from today:
2:36 AM
jchen.6727 posted more notes to github, going to start on a cartoon of it ** -> may already have good cartoons existing. but some of the ones I've observed do not really incorporate inhib pop.  densities or descending input from rostral ventromedial medulla.
seems like deeper lamina not as well understood, which is a problem because the density of WDR is higher as one moves into deeper lamina.
I also think its notable that as we get into deeper layers, the NK1R projection neurons become more dendritically complex and receive greater numbers of inputs.
** Just realized I could steal my brother's Wacom tablet to do this! (edited) 
2:49 AM
jchen.6727 ---that is, superficial NK1R projection neurons have dendrites mostly confined to their lamina (LI), seems like primarily excitatory, whilst deeper NK1R projection neurons have dendrites extending superficially.
---descending inhibitory inputs are heavily LII
---inhibitory populations increase as we move from LI->LIII
Prior modelling, NK1R played a heavy role in windup, which I find curious in this context (edited) 
2:57 AM
jchen.6727 the pattern that we get more WDR neurons as we move deeper, that we see these inhibitory signals becoming more detailed as we move deeper
and that the NK1R projection neurons possess this more vertical dendritic organization is elegant, though may be misleading. (edited) 
3:09 AM
jchen.6727 or, we can forego the 'WDR' label, say we have these morphologically and  dendritically distinct projection neurons as we move into deeper lamina, and see what they are.

* 5.03 Google draw posted, consolidating information regarding DHN. Additionally genrn using VClamp when mods are using Crank-Nicholson
** seems like this may be cause of problem with strange peak in MM nav18?
** TODO switch back to SEClamp?
