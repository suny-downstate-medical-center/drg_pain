* 4.01 Email Regarding Project / concerns about Choi et. al. 2011
Some concerns regarding model referenced in a Choi et. al. paper describing NaV1.7 NaV1.8 activity in a small diameter sensory afferent soma. 
At this time, getting source code is unlikely.
https://paperpile.com/app/p/3f0c8cd7-9f85-0980-8494-8f3fdbdd17ef
** Concerns
<<#>> are areas of confusion.
In Materials and Methods:

Passive membrane properties of the model neuron
"Action potential firing was studied using a single compartment cylindrical model of length 30 μm and <<1>>radius 23 μm, simulating a small sensory neuron with a 2,168 μm2 surface area and <<2>>20.2 pF/cm2 capacitance, based on electrically and microscopically measured values (Choi et al. 2007)."

1. Is this "radius 23 μm" value the radius or the diameter? It seems like this is the diameter as that will provide a 2,168 um2 surface area.
2. Can this "20.2 pF/cm2" value be clarified? It seemed very low. When Choi et al. 2007 was reviewed, the cell capacitance reported there is around 26 pF which, assuming same surface area of 2,168 μm2 (2.168e-5 cm2) should give a value around 1.2e6 pF/cm2. It seems like 1.2e6 pF/cm2 -- or 1.2 μF/cm2 happens to be closer to capacitance of other models. 

KDR potassium current
"The KDR current was defined as: IKDR = gKDR * n * (V − Ek), where gKDR is the delayed rectifier potassium conductance and n is a dimensionless activation variable that varies between 0 and 1. The kinetic characterization of the channel described by Schild et al. (1994) has been used <<1>> with alphan = 0.001265 * (V + 14.273)/{1 − exp[(V + 14.273)/−10]}; betan = 0.125 * exp(V + 55/−2.5); and ninf = 1/{1 + exp[(V + 14.62)/−18.38]}. The peak conductance for KDR (gKDR) was set to 0.0035 S/cm2, which corresponds to 6 nA potassium current at 0 mV."

1. Can the equation for tau be clarified, we assumed it to be:
taun = 1 / (alphan + betan)
As it was not given. However, when reviewing the prior paper, the tau equation is different. Because of this, there is some confusion over whether this change to tau should be used.
tau as given in Schild et al. (1994)
taun = (1 / (alphan + betan)) + 1

Nav1.8 sodium current.
The Nav1.8 sodium current (INav1.8) was best fit with a HH model that employed <<1>> only one activation gate: INav1.8 = gNav1.8 * m * h * (V − ENa), where gNav1.8 is the Nav1.8 sodium conductance and m and h are dimensionless activation and inactivation variables that vary between 0 and 1. Based on previous reports (Herzog et al. 2001; Sheets et al. 2007), we defined the following equations for Nav1.8 m and h <<1>>: m = m + [1 − exp(−dt/taum)] * (minf − m), h = h + [1 − exp(−dt/tauh)] * (hinf − h), alpham = 2.85 − (2.839)/{1 + exp[(v − 1.159)/13.95]}; betam = (7.6205)/{1 + exp[(v + 46.463)/8.8289]}; taum = 1/(alpham + betam); minf = alpham/(alpham + betam); tauh = (1.218 + 42.043 * exp{−[(v + 38.1) ∧ 2]/(2 * 15.19 ∧ 2)}); hinf = 1/{1 + exp[(v + 32.2)/4]}. The peak current of 25 nA was modeled by setting the peak value gNav1.8 to 0.026 S/cm2, which was chosen to match experimental values (Choi et al. 2007; Cummins and Waxman 1997).

1. There is confusion over the use of the modelling with only one m, the "INav1.8 = gNav1.8 * m * h * (V − ENa)" equation, as the equations for rate/ tau, inf equations:

alpha_m = 2.85-(2.839)/(1+exp((v-1.159)/13.95))
beta_m = (7.6205)/(1+exp((v+46.463)/8.8289))

tau_h = (1.218+42.043*exp(-((v+38.1)^2)/(2*15.19^2)))
inf_h = (1)/(1 + exp((v+32.2)/4))

all come from Sheets et al. 2007, though in this paper, the formula for current does not use a single m to describe activation but instead is:

ina = gnabar * m^3 * h * (v-ena)

The one activation gate from Herzog et al. 2001, which uses current equation described in the paper has characterised m, h differently:

alpham  = 1.032/{1 + exp[(υ + 6.99)/−14.87115]}
betam   = 5.79/{1 + exp[(υ + 130.4)/22.9]}

alphah  = 0.06435/{1 + exp[(υ + 73.26415)/3.71928]}
betah   = 0.13496/{1 + exp[(υ + 10.27853)/(−9.09334)]}
* 4.12 Calculating proper nseg given a dlambda and max frequency
Link is here:
https://www.neuron.yale.edu/neuron/static/docs/d_lambda/d_lambda.html
Some additional observations regarding nseg calculation in myelinated axons:
https://www.neuron.yale.edu/phpBB/viewtopic.php?t=2271
** Implemented in python:
def cal_nseg( sec, freq, d_lambda ):
#neuron+python of https://www.neuron.yale.edu/neuron/static/docs/d_lambda/d_lambda.html
    nseq = lambda fc_: int((sec.L / (d_lambda * fc_) + 0.9) / 2) * 2 + 1
    fpfrc = 4 * h.PI * freq * sec.Ra * sec.cm
    h.define_shape()
    fc = 0
    n3d = sec.n3d()
    if n3d < 2:
        fc = 1e5 * h.sqrt(sec.diam / (fpfrc))
        return nseq(fc)

    x1 = sec.arc3d(0)
    d1 = sec.diam3d(0)

    for i in range(n3d):
        x2 = sec.arc3d(i)
        d2 = sec.diam3d(i)
        fc += (x2 - x1) / h.sqrt(d1 + d2)
        x2 = x1
        d2 = d1

    fc *= h.sqrt(2) * 1e-5 * h.sqrt(fpfrc)
    return nseq(sec.L/fc)
* 4.21 Notes on cell parameterization on netpyne
Note that due to storage of cell parameters in dictionaries
copy.deepcopy() does not work with cell parameters (recursion limit reached)
Pushed onto genrn git as commit to revisit this issue later ...
** Post on Slack
2:00 PM
jchen.6727 also, I'm curious about this --
the cellParams nested dictionary structure can causes issues when trying to vary individual parameters through a cell population
for instance:
----------------------------------------------------------------------
# some cell with soma length of 5
cellParams = {...'secs': {...'soma': {'geom': {'L':5...}...}...}...}
netParams.cellParams['length=5'] = cellParams
# some cell with soma same as before but length of 10
cellParams['secs']['soma']['geom'] = 10
netParams.cellParams['length=10'] = cellParams
----------------------------------------------------------------------
Since these parameters being handled as pointers, we are changing the length of both cells to 10.
copy.deepcopy() doesn't seem to work on these cellParams dictionaries because of a recursion limit?
various ways to handle this case though so
2:07 PM
jchen.6727 including parameterization via batchfile in context of single cells only
or importing a whole bunch of cell parameters to generate new dictionaries -> essentially doing "deepcopy"
* 4.22 using re and lambda functions to handle data grouping for analysis
Can use re and lambda to filter strings and cell ids to retrieve a specific trace or group of traces
** select excerpts from code
# use of dictionary to define several different "groups" to be plotted, these groups contain
tracegroups = {
    ...
    'current(Na)' : {'rgx': re.compile('NaV')       , 'xaxis': 't (ms)', 'yaxis': 'i (nA/cm2)' , 'conds': lambda id: id == 0},
}
...
for group in tracegroups:
    grp = tracegroups[group]
...
    grp['rgx'].search(key)
...
        grp['conds'](id)
* 4.24 checking the ion of an added mechanism
** added more functions to genrn to handle mechanisms
can now get mechanisms of a section, as well as mechanisms by section by ion:
with the developed modules, this is done via
mechlist = cell('secname').ions[ion]
easier to set up containers to store important attributes of a section in future
note that pythons getattr(), hasattr(), setattr() are very useful given neuron's proclivity to "hide" variables in difficult to access places
*** TODO set up a similar mechanism for point processes
*** TODO look into cython compilation
** work on neuron+python script to evaluate cells generated by genrn()
** now compiling all NaV isoforms, handling within python
* 4.25 notes on recording from point processes, changing h.dt during a simulation
** process for recording from a point process requires some finesse as recording needs to be done from the point process object.
*** excerpt from netpyne code, cell.py:196
if 'mech' in params:  # eg. soma(0.5).hh._ref_gna
    ptr = getattr(getattr(self.secs[params['sec']]['hObj'](params['loc']), params['mech']), '_ref_'+params['var'])
elif 'synMech' in params:  # eg. soma(0.5).AMPA._ref_g
    sec = self.secs[params['sec']]
    synMech = next((synMech for synMech in sec['synMechs'] if synMech['label']==params['synMech'] and synMech['loc']==params['loc']), None)
    ptr = getattr(synMech['hObj'], '_ref_'+params['var'])
** getting TODO:120 done would increase usefulness of genrn() in this sense
** work on nrnCSA.py
*** stims, traces implemented in a way that handles generic inputs.
*** parameter variation at specific times possible, currently used to implement dt variation.
** DONE h.stdinit() discrepancy in v_init, does not seem to initialize to correct values, additional h.finitialize(h.v_init) look into this
note that stdrun library can be found at /nrn/share/lib/hoc/stdrun.hoc
looks like v_init is not being changed properly with just h.v_init assignment.
*** changing dt after starting a simulation requires a call to h.setdt()
https://www.neuron.yale.edu/phpBB/viewtopic.php?t=2665
* 4.26 notes on recording current
** the value recorded at segment is a current density (mA/cm2), to calculate for current at a segment, need to know area of the segment.
** with a genrn() this is done through:
** genrn.sec(x).area() * 1e-8
** total surface area of a cell can also be calculated through:
area = 0
for sec in genrn:
    for seg in sec:
        area += seg.area()
area *= 1e-8
** area returns in microns squared
** unit conversion:
additional calculations - surface area at our recording (current density * surface area = current)
mA/cm2 * um2 * (cm2 / (1e8 * um2))(=1) * ((1e6 * nA) / mA)(=1)
mA * um2 * cm2 * 1e6nA                      mA                      nA*cm2   
----------------------  conversion is:  D (-----) * A (um2) * 1e-2 -------- = D * A * 1e-2 (nA)                        
  cm2 * 1e8um2 * mA                         cm2                     um2*mA
** examples of mutable objects, python
a = [1,2,3]
b = [a]*3
b
Out[4]: [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
a[2] = 'foo'
b
Out[6]: [[1, 2, 'foo'], [1, 2, 'foo'], [1, 2, 'foo']]
** some list comprehensions, python
[i if y else z for i in arr]
i if condition y is true, z if condition y is false for i in arr
** issue with L, diam caught when evaluating with area()
on printout of area, caught issue with modifications to L, diam assignments not being reflected on the section.
ultimately, the best method of catching this was using h.psection(), which has been implemented within the genrn() repr function (can be called when displaying the object)
value assignment automatically causes creation of the variable of an object.
on another note, the area of the default segment happens to be: 157079.63267948964
